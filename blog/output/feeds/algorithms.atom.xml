<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>habeebq</title><link href="/" rel="alternate"></link><link href="/feeds/algorithms.atom.xml" rel="self"></link><id>/</id><updated>2016-05-16T00:00:00+02:00</updated><entry><title>Using Modular Multiplicative Inverse</title><link href="/using-modular-multiplicative-inverse.html" rel="alternate"></link><updated>2016-05-16T00:00:00+02:00</updated><author><name>habeebq</name></author><id>tag:,2016-05-16:using-modular-multiplicative-inverse.html</id><summary type="html">&lt;p&gt;I was looking at an algorithm somebody came up with, and it invovled an inverse modulo function. I had not come across this before so it really grabbed by attention as I tried to understand what it does.&lt;/p&gt;
&lt;p&gt;This page on &lt;a href="https://www.khanacademy.org/computing/computer-science/cryptography/modarithmetic/a/modular-inverses"&gt;Khans Academy&lt;/a&gt; seemed like a very useful introduction to the process.&lt;/p&gt;
&lt;p&gt;In, short the multiplicative modular inverse &lt;code&gt;iA&lt;/code&gt; of a number &lt;code&gt;A&lt;/code&gt; for a modulo &lt;code&gt;C&lt;/code&gt; is defined as&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;(A * iA) mod C = 1
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Sometimes the modular inverse does not exist though, both A and C need to be coprime.&lt;/p&gt;
&lt;p&gt;The interesting thing about the modular inverse is that it returns a value within the range C that will be unique.&lt;/p&gt;
&lt;p&gt;This allows it to be used as a hashing or an obfuscation method that can be implemented fairly cheaply.&lt;/p&gt;</summary></entry></feed>